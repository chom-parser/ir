# [doc = r" Parsing errors."] pub enum Error { # [doc = r" Error comming from the lexer."] Lexer (crate :: glue :: Error) , # [doc = r" Unexpected lexer token."] UnexpectedToken (Option < crate :: lexer :: Token >) , # [doc = r" Unexpected AST node."] UnexpectedNode (Node) } impl From < crate :: glue :: Error > for Error { fn from (e : crate :: glue :: Error) -> Self { Self :: Lexer (e) } } pub enum Node { Constant (crate :: ast :: Constant) , Expr (crate :: ast :: Expr) } pub enum Item { Token (crate :: lexer :: Token) , Node (crate :: parser :: Node) } pub fn parse_expr < L : :: std :: iter :: Iterator < Item = :: std :: result :: Result < :: source_span :: Loc < crate :: lexer :: Token > , :: source_span :: Loc < Error > , > , > , > (lexer : & mut L ,) -> :: std :: result :: Result < :: source_span :: Loc < crate :: ast :: Expr > , :: source_span :: Loc < Error >> { let mut position = :: source_span :: Position :: default () ; let mut stack = Vec :: new () ; let mut any_node_opt = None ; let mut state = 1u32 ; loop { match state { 1u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { crate :: parser :: Node :: Constant (node) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Node (crate :: parser :: Node :: Constant (node)) , span) , state)) ; state = 6u32 ; } crate :: parser :: Node :: Expr (node) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Node (crate :: parser :: Node :: Expr (node)) , span) , state)) ; state = 7u32 ; } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { Some (crate :: lexer :: Token :: Int (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Int (token)) , span) , state)) ; state = 2u32 ; } Some (crate :: lexer :: Token :: Char (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (token)) , span) , state)) ; state = 3u32 ; } Some (crate :: lexer :: Token :: Keyword (crate :: lexer :: Keyword :: Range)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Keyword (crate :: lexer :: Keyword :: Range)) , span) , state)) ; state = 4u32 ; } Some (crate :: lexer :: Token :: String (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: String (token)) , span) , state)) ; state = 5u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 7u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { None => { state = 8u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 8u32 => { let (any_item0 , _) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Node (crate :: parser :: Node :: Expr (result)) = item0_spanless { let span = item0_span ; break Ok (:: source_span :: Loc :: new (result , span)) } else { unreachable ! () } } 6u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Node (crate :: parser :: Node :: Constant (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Expr (crate :: ast :: Expr (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } 5u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: String (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: String (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } 4u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { Some (crate :: lexer :: Token :: Char (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (token)) , span) , state)) ; state = 9u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 9u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { Some (crate :: lexer :: Token :: Char (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (token)) , span) , state)) ; state = 10u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 10u32 => { let (any_item2 , _) = stack . pop () . unwrap () ; let (any_item1 , _) = stack . pop () . unwrap () ; let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item2_spanless , item2_span) = any_item2 . into_raw_parts () ; let (item1_spanless , item1_span) = any_item1 . into_raw_parts () ; let (_ , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (item2)) = item2_spanless { if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (item1)) = item1_spanless { let span = item0_span . union (item2_span) ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: Range (:: source_span :: Loc :: new (item1 , item1_span) , :: source_span :: Loc :: new (item2 , item2_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } else { unreachable ! () } } 3u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: Char (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } 2u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Int (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: Int (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } _ => { unreachable ! () } } } } pub fn parse_constant < L : :: std :: iter :: Iterator < Item = :: std :: result :: Result < :: source_span :: Loc < crate :: lexer :: Token > , :: source_span :: Loc < Error > , > , > , > (lexer : & mut L ,) -> :: std :: result :: Result < :: source_span :: Loc < crate :: ast :: Constant > , :: source_span :: Loc < Error >> { let mut position = :: source_span :: Position :: default () ; let mut stack = Vec :: new () ; let mut any_node_opt = None ; let mut state = 0u32 ; loop { match state { 0u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { crate :: parser :: Node :: Constant (node) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Node (crate :: parser :: Node :: Constant (node)) , span) , state)) ; state = 11u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { Some (crate :: lexer :: Token :: Int (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Int (token)) , span) , state)) ; state = 2u32 ; } Some (crate :: lexer :: Token :: Char (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (token)) , span) , state)) ; state = 3u32 ; } Some (crate :: lexer :: Token :: Keyword (crate :: lexer :: Keyword :: Range)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Keyword (crate :: lexer :: Keyword :: Range)) , span) , state)) ; state = 4u32 ; } Some (crate :: lexer :: Token :: String (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: String (token)) , span) , state)) ; state = 5u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 11u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { None => { state = 12u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 12u32 => { let (any_item0 , _) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Node (crate :: parser :: Node :: Constant (result)) = item0_spanless { let span = item0_span ; break Ok (:: source_span :: Loc :: new (result , span)) } else { unreachable ! () } } 5u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: String (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: String (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } 4u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { Some (crate :: lexer :: Token :: Char (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (token)) , span) , state)) ; state = 9u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 9u32 => { let (any_node_opt_spanless , span) = :: source_span :: Loc :: transposed (any_node_opt . take () , position . into ()) . into_raw_parts () ; match any_node_opt_spanless { Some (any_node) => { match any_node { unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedNode (unexpected) , span)) } } } None => { let any_token_opt = lexer . next () . transpose () . map_err (| e | e . inner_into ()) ? ; let (any_token_opt_spanless , span) = :: source_span :: Loc :: transposed (any_token_opt , position . into ()) . into_raw_parts () ; position = span . end () ; match any_token_opt_spanless { Some (crate :: lexer :: Token :: Char (token)) => { stack . push ((:: source_span :: Loc :: new (crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (token)) , span) , state)) ; state = 10u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (Error :: UnexpectedToken (unexpected) , span)) } } } } } 10u32 => { let (any_item2 , _) = stack . pop () . unwrap () ; let (any_item1 , _) = stack . pop () . unwrap () ; let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item2_spanless , item2_span) = any_item2 . into_raw_parts () ; let (item1_spanless , item1_span) = any_item1 . into_raw_parts () ; let (_ , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (item2)) = item2_spanless { if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (item1)) = item1_spanless { let span = item0_span . union (item2_span) ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: Range (:: source_span :: Loc :: new (item1 , item1_span) , :: source_span :: Loc :: new (item2 , item2_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } else { unreachable ! () } } 3u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Char (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: Char (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } 2u32 => { let (any_item0 , saved_state) = stack . pop () . unwrap () ; let (item0_spanless , item0_span) = any_item0 . into_raw_parts () ; if let crate :: parser :: Item :: Token (crate :: lexer :: Token :: Int (item0)) = item0_spanless { let span = item0_span ; position = span . end () ; any_node_opt = Some (:: source_span :: Loc :: new (crate :: parser :: Node :: Constant (crate :: ast :: Constant :: Int (:: source_span :: Loc :: new (item0 , item0_span))) , span)) ; state = saved_state ; } else { unreachable ! () } } _ => { unreachable ! () } } } }