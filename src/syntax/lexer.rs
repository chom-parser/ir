# [doc = r" Lexer."] pub struct Lexer < I : Iterator , M > { # [doc = r" Source character stream."] source : :: std :: iter :: Peekable < I > , # [doc = r" Token buffer."] buffer : String , # [doc = r" Character metrics."] metrics : M , # [doc = r" Token span."] span : :: source_span :: Span } pub enum Token { Int (crate :: glue :: Int) , Char (crate :: glue :: Char) , Keyword (crate :: lexer :: Keyword) , String (crate :: glue :: String) } pub enum Keyword { Range } impl < E : Into < crate :: glue :: Error > , I : Iterator < Item = Result < char , E >> , M : :: source_span :: Metrics , > Lexer < I , M > { fn peek_char (& mut self) -> Result < Option < char > , :: source_span :: Loc < crate :: glue :: Error > , > { match self . source . peek () { Some (Ok (c)) => Ok (Some (* c)) , Some (Err (_)) => Err (self . consume_char () . unwrap_err ()) , None => Ok (None) , } } fn consume_char (& mut self ,) -> Result < () , :: source_span :: Loc < crate :: glue :: Error >> { match self . source . next () { Some (Ok (c)) => { self . buffer . push (c) ; self . span . push (c , & self . metrics) ; Ok (()) } Some (Err (e)) => Err (:: source_span :: Loc :: new (e . into () , self . span . end () . into ())) , None => Ok (()) , } } fn next_token (& mut self ,) -> Result < Option < :: source_span :: Loc < Token >> , :: source_span :: Loc < crate :: glue :: Error > , > { self . buffer . clear () ; self . span . clear () ; let mut state = 0u32 ; loop { match state { 0u32 => { match self . peek_char () ? { Some ('"') => { self . consume_char () ? ; state = 1u32 ; } Some ('\'') => { self . consume_char () ? ; state = 2u32 ; } Some ('r') => { self . consume_char () ? ; state = 3u32 ; } Some ('0' ..= '9') => { self . consume_char () ? ; state = 4u32 ; } Some ('\t' ..= '\r' | ' ') => { self . consume_char () ? ; state = 5u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 1u32 => { match self . peek_char () ? { Some ('\u{0}' ..= '!' | '#' ..= '[' | ']' ..= '\u{d7ff}' | '\u{e000}' ..= '\u{10ffff}') => { self . consume_char () ? ; state = 1u32 ; } Some ('\\') => { self . consume_char () ? ; state = 6u32 ; } Some ('"') => { self . consume_char () ? ; state = 7u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 2u32 => { match self . peek_char () ? { Some ('\u{0}' ..= '&' | '(' ..= '\u{d7ff}' | '\u{e000}' ..= '\u{10ffff}') => { self . consume_char () ? ; state = 8u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 3u32 => { match self . peek_char () ? { Some ('a') => { self . consume_char () ? ; state = 9u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 6u32 => { match self . peek_char () ? { Some ('\u{0}' ..= '!' | '#' ..= '[' | ']' ..= '\u{d7ff}' | '\u{e000}' ..= '\u{10ffff}') => { self . consume_char () ? ; state = 1u32 ; } Some ('\\') => { self . consume_char () ? ; state = 6u32 ; } Some ('"') => { self . consume_char () ? ; state = 10u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 9u32 => { match self . peek_char () ? { Some ('n') => { self . consume_char () ? ; state = 11u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 11u32 => { match self . peek_char () ? { Some ('g') => { self . consume_char () ? ; state = 12u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 12u32 => { match self . peek_char () ? { Some ('e') => { self . consume_char () ? ; state = 13u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 8u32 => { match self . peek_char () ? { Some ('\u{0}' ..= '&' | '(' ..= '\u{d7ff}' | '\u{e000}' ..= '\u{10ffff}') => { self . consume_char () ? ; state = 8u32 ; } Some ('\'') => { self . consume_char () ? ; state = 14u32 ; } unexpected => { break Err (:: source_span :: Loc :: new (crate :: glue :: unexpected (unexpected) , self . span)) } } } 4u32 => { match self . peek_char () ? { Some ('0' ..= '9') => { self . consume_char () ? ; state = 4u32 ; } _ => { break Ok (Some (:: source_span :: Loc :: new (crate :: lexer :: Token :: Int (crate :: glue :: int (self . buffer . as_str ()) . map_err (| e | :: source_span :: Loc :: new (e , self . span)) ?) , self . span))) } } } 14u32 => { match self . peek_char () ? { _ => { break Ok (Some (:: source_span :: Loc :: new (crate :: lexer :: Token :: Char (crate :: glue :: char (self . buffer . as_str ()) . map_err (| e | :: source_span :: Loc :: new (e , self . span)) ?) , self . span))) } } } 13u32 => { match self . peek_char () ? { _ => { break Ok (Some (:: source_span :: Loc :: new (crate :: lexer :: Token :: Keyword (crate :: lexer :: Keyword :: Range) , self . span))) } } } 7u32 => { match self . peek_char () ? { _ => { break Ok (Some (:: source_span :: Loc :: new (crate :: lexer :: Token :: String (crate :: glue :: string (self . buffer . as_str ()) . map_err (| e | :: source_span :: Loc :: new (e , self . span)) ?) , self . span))) } } } 10u32 => { match self . peek_char () ? { Some ('\u{0}' ..= '!' | '#' ..= '[' | ']' ..= '\u{d7ff}' | '\u{e000}' ..= '\u{10ffff}') => { self . consume_char () ? ; state = 1u32 ; } Some ('\\') => { self . consume_char () ? ; state = 6u32 ; } Some ('"') => { self . consume_char () ? ; state = 7u32 ; } _ => { break Ok (Some (:: source_span :: Loc :: new (crate :: lexer :: Token :: String (crate :: glue :: string (self . buffer . as_str ()) . map_err (| e | :: source_span :: Loc :: new (e , self . span)) ?) , self . span))) } } } 5u32 => { match self . peek_char () ? { Some ('\t' ..= '\r' | ' ') => { self . consume_char () ? ; state = 5u32 ; } _ => { self . buffer . clear () ; self . span . clear () ; } } } _ => { unreachable ! () } } } } } impl < E : Into < crate :: glue :: Error > , I : Iterator < Item = Result < char , E >> , M : :: source_span :: Metrics , > Iterator for Lexer < I , M > { type Item = Result < :: source_span :: Loc < Token > , :: source_span :: Loc < crate :: glue :: Error > , > ; fn next (& mut self) -> Option < Self :: Item > { self . next_token () . transpose () } }